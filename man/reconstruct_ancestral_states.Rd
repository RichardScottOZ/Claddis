% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reconstruct_ancestral_states.r
\name{reconstruct_ancestral_states}
\alias{reconstruct_ancestral_states}
\title{Reconstruct ancestral states using parsimony}
\usage{
reconstruct_ancestral_states(tree, tip_states, stepmatrix, weight = 1)
}
\arguments{
\item{tree}{A tree (phylo object).}

\item{tip_states}{A labelled vector of tip states. These should be discrete and match the row and column headings in \code{stepmatrix}, with labels matching the tip labels of \code{tree}.}

\item{stepmatrix}{Either the character type (one of \code{"ordered"} or \code{"unordered"}) or a custom-specified step matrix. If the latter this must be square with identical row and column names correspnding to the values in \code{tip_states}. The diagonal must be zero, but off-diagonal values can be any non-negative real number. I.e., they needn't be integers, and the matrix does not need to be symmetric. Note that for transitions the rows are considered the "from" values, and the columns the "to" value. Thus a cost for the transition from state "0" to state "1" would be specified by \code{stepmatrix["0", "1"]}. (This is only relevant where matrices are asymmetric in tranistion costs.)}

\item{weight}{The character weight (defaults to one).}
}
\value{
A list with multiple components, including:

\item{length}{The tree length (number of steps).}
\item{most_parsimonious_reconstructions}{A matrix where rows correspond to ALL nodes (i.e., terminal and internal) in the order numbered by \code{ape}, and columns correspond to every unique most parsimnious reconstruction. I.e., if there is only one most parsimonious reconstruction there will be only one column.}


Users may also wish to refer to the more complex whole-matrix, likelihood-based function \link{estimate_ancestral_states}. Although, note that eventually parsimony will simply be an option to that function.
}
\description{
Given a tree, discrete states for each tip, and either a specific stepmatrix or character type, returns the most parsimonious ancestral reconstruction(s).
}
\details{
Text.

# Uses Swofford and Maddison 1992 general solution as covers more base's but is also slower.
# Rooted tres only as direction fucking matters and roots have meaning (stepmatrices that are asymmetric)
# Option to fix root state (polarize) somehow
# From is row, to is column
# MANUAL: generalized solution as accounts for more possibilities
# MANUAL: really only for rooted trees (unrooted possible using same methods (see Swofford and Maddison(1992), but unclear why you would want to do this with trees without direction of time (i.e., a root).
# MANUAL: works with multifirctaions and doesn't reuire a fully bifurcating tree, but does assume polytomies are therefore "hard".
# MANUAL: Swofford and Maddison (1992; p210): "Both [ACCTRAN and DELTRAN] start by either assuming that the ancestral state is known or by choosing a state from the set of optimal assignments to the root node" - i.e., always an arbitrainess problem at root!
MISSING DATA (NA) IS DEALT WITH BY SETTING ALL TIP VALUES FOR A MISSING STATE TO ZERO (AS PER SWOFFORD AND MADDISON 1992).
UNCERTAIN STATES (E.G., 0/1) CONSTRAIN ANCESTRAL STATES SLIGHTLY MORE THAN NA (ASSUMING THEY EXCLUDE SOME STATES. IMPLEMENTATION SAME AS SWOFFORD AND MADDISON (1992).

ASYMMETRIC TRANSITIONS REQUIRE YOU TO KNOW POLARITY A PRIORI!
HOW TO TREAT POLYTOMIES? MANY ISSUES RAISED IN SWOFFORD AND MADDISON (1992). ALTERNATIVE APPROACH IN LIKELIHOOD SUGGESTED BY REVELL.
}
\examples{

# Set up the example from Swofford and Maddison 1992:
tree <- ape::read.tree(text = "((C,(A,B)),(D,E));")
tip_states <- c(A = 1, B = 2, C = 2, D = 1, E = 0)
stepmatrix <- matrix(
  data = c(0, 1, 2, 1, 0, 1, 2, 1, 0),
  nrow = 3,
  ncol = 3,
  dimnames = list(0:2, 0:2)
)

# Look at stepmatrix to confirm it is symmetric and ordered:
stepmatrix

# Reconstruct ancestral states:
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "ordered"
)$most_parsimonious_reconstructions

# Plot all most parsimonious reconstructions on the tree:
par(mfrow = c(1, ncol(x = node_estimates)))
for(i in 1:ncol(x = node_estimates)) {
  plot(x = tree, show.tip.label = FALSE)
  tiplabels(text = tip_states[tree$tip.label], cex = 2)
  nodelabels(text = node_estimates[6:9, i], cex = 2)
}

# Repeat using the simpler "ordered" option:
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "ordered"
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(x = node_estimates)) {
  plot(x = tree, show.tip.label = FALSE)
  tiplabels(text = tip_states[tree$tip.label], cex = 2)
  nodelabels(text = node_estimates[6:9, i], cex = 2)
}

# Repeat but considering the character "unordered":
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "unordered"
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(x = node_estimates)) {
  plot(x = tree, show.tip.label = FALSE)
  tiplabels(text = tip_states[tree$tip.label], cex = 2)
  nodelabels(text = node_estimates[6:9, i], cex = 2)
}

# Repeat using a stepmatrix that penalises gains:
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = matrix(
    data = c(0, 1, 2, 999, 0, 1, 999, 999, 0),
    nrow = 3,
    ncol = 3,
    dimnames = list(0:2, 0:2)
  )
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(x = node_estimates)))
for(i in 1:ncol(node_estimates)) {
  plot(x = tree, show.tip.label = FALSE)
  tiplabels(text = tip_states[tree$tip.label], cex = 2)
  nodelabels(text = node_estimates[6:9, i], cex = 2)
}

# Repeat using a stepmatrix that penalises losses:
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = matrix(
    data = c(0, 999, 999, 1, 0, 999, 2, 1, 0),
    nrow = 3,
    ncol = 3,
    dimnames = list(0:2, 0:2)
  )
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(node_estimates)) {
  plot(x = tree, show.tip.label = FALSE)
  tiplabels(text = tip_states[tree$tip.label], cex = 2)
  nodelabels(text = node_estimates[6:9, i], cex = 2)
}

# Ordered with polytomies:
tree <- ape::read.tree(text = "((C,A,B),(D,E));") # Two non-root internal
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "ordered"
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(node_estimates)) {
  plot(tree, show.tip.label = FALSE)
  tiplabels(tip_states[tree$tip.label], cex = 2)
  nodelabels(node_estimates[6:8, i], cex = 2)
}
tree <- ape::read.tree(text = "((C,A,B),D,E);") # One non-root internal
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "ordered"
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(node_estimates)) {
  plot(tree, show.tip.label = FALSE)
  tiplabels(tip_states[tree$tip.label], cex = 2)
  nodelabels(node_estimates[6:7, i], cex = 2)
}
tree <- ape::read.tree(text = "(C,A,B,D,E);") # Star tree
node_estimates <- reconstruct_ancestral_states(
  tree = tree,
  tip_states = tip_states,
  stepmatrix = "ordered"
)$most_parsimonious_reconstructions
par(mfrow = c(1, ncol(node_estimates)))
for(i in 1:ncol(node_estimates)) {
  plot(tree, show.tip.label = FALSE)
  tiplabels(tip_states[tree$tip.label], cex = 2)
  nodelabels(node_estimates[6, i], cex = 2)
}

}
\references{
Swofford, D. L. and Maddison, W. P., 1992. Parsimony, character-state reconstructions, and evolutionary inferences. \emph{In}  R. L. Mayden (ed.) Systematics, Historical Ecology, and North American Freshwater Fishes. Stanford University Press, Stanford, p187-223.
}
\seealso{
\link{estimate_ancestral_states}
}
\author{
Graeme T. Lloyd \email{graemetlloyd@gmail.com}
}
