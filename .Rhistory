360 / (side_length / (2 * pi * opposite_length))
# Get the latitude if travelling south for side-length distance from North pole:#
					latitude_from_north_pole <- 90 - ((side_length * 360) / (2 * pi * EarthRad))#
					# Get adjacent length (height above centre of sphere that corresponds to latitude just derived:#
					adjacent_length <- sin(abs(latitude_from_north_pole) * (pi / 180)) * EarthRad#
					adjacent_length <- cos(latitude_from_north_pole) * EarthRad#
#
					# Get opposite length (radius of small circle along which we wish to travel):#
					opposite_length <- sqrt((EarthRad ^ 2) - (adjacent_length ^ 2))
opposite_length
adjacent_length
side_length / (2 * pi * adjacent_length)
?atan
s <- (3 * side_length) / 2
4 * atan(sqrt(tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2)))
s
side_length
sqrt(tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2))
tan(s / 2)
tan((s - side_length) / 2)
tan(s / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2) * tan((s - side_length) / 2)
tan(1.1)
tan(90)
tan(0)
tan(180)
tan(270)
tan(360)
tan(1234801)
tan(-1234801)
s - side_length
side_length
s <- (3 * side_length) / 2
tan((s - side_length) / 2)
?geosphere
areaPolygon
areaPolygon-method
?geosphere
showMethods("areaPolygon")
library(geosphere)
min_separation
min_separation * 2
GetThetaFromGreatCircleDistance(min_separation * 2)
GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(min_separation * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				(y / 2)  / (z / 2)
asin((y / 2) / (z / 2))
asin((y / 2) / (z / 2)) * (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180)
asin((y / 2) / (z / 2)) / (pi / 180) * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
first_circle_long
first_circle_lat
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle)
(GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360
EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
min_separation
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
#
				new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) + spherical_angle) %% 360#
				GetGreatCircleDistanceFromLongLat(first_circle_long, first_circle_lat, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$long, EndPoint(first_circle_long, first_circle_lat, new_bearing, min_separation)$lat)
GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)
spherical_angle
min_separation
x <- min_separation * 2
x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
				x <- min_separation#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation *  2#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- min_separation * 4#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
2 * pi * EarthRad
0.5 * pi * EarthRad
x <- 0.5 * pi * EarthRad
y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
x <- 0.0000000001#
				y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x))#
				z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(x * 2))#
#
				spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2
spherical_angle
# Get the spherical angle for an equilateral triangle where its sides (as great circle distances) are known:#
	GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength <- function(side_length, EarthRad = 6367.4447) {#
# Check this works for triangles larger than equivalent of 90-degrees of latitude on each side!#
		# Get y (which will be double the opposite for the triangle we are trying to solve):#
		y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length))#
		# Get z which will be double the hypotenuse for the triangle we are trying to solve):#
		z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length * 2))#
		# Solve the traingle for theta (the spherical angle) and convert to degrees:#
		spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
		# Return the spherical angle:#
		return(spherical_angle)#
	}
GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)
spherical_angle
new_bearing <- (GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat) - spherical_angle) %% 360
new_bearing
GetBearing(first_circle_long, first_circle_lat, second_circle_lat, second_circle_lat)
spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, first_circle_long, first_circle_lat)#
#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_1$long, new_continent_1$lat)#
				GetGreatCircleDistanceFromLongLat(second_circle_long, second_circle_lat, new_continent_2$long, new_continent_2$lat)
sample(c(1, 2), 1)
new_continent_1
unlist(new_continent_1)
rbind(unlist(new_continent_1), unlist(new_continent_2))
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 1:2]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
third_circle
third_circle$long
third_circle["long"]
c(1, first_circle_long, first_circle_lat)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3)
matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
circles
# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
c(2, second_circle$long, second_circle$lat)
rbind(circles, c(2, second_circle$long, second_circle$lat))
# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))
c(3, third_circle["long"], third_circle["lat"])
rbind(circles, c(3, third_circle["long"], third_circle["lat"]))
N_continents
N_continents <- 7
N_continents > nrow(circles)
N_continents = 7
radius = 500
start_configuration = "supercontinent"
squishiness = 0.25
# GreatCircleDistance function:#
	GetGreatCircleDistanceFromLongLat <- function(long1, lat1, long2, lat2, EarthRad = 6367.4447) {#
#
		long1 <- long1 * (pi / 180)#
		lat1 <- lat1 * (pi / 180)#
		long2 <- long2 * (pi / 180)#
		lat2 <- lat2 * (pi / 180)#
# Maybe replace this with Haversine:#
		gcdist <- acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(abs(long1 - long2))) * EarthRad#
#
		return(gcdist)#
	}#
	GetBearing <- function(start_long, start_lat, end_long, end_lat) {#
# Check that lat and long are not both identical (where no bearing is possible)#
		start_long <- start_long * (pi / 180)#
		start_lat <- start_lat * (pi / 180)#
		end_long <- end_long * (pi / 180)#
		end_lat <- end_lat * (pi / 180)#
		bearing <- atan2(sin(end_long - start_long) * cos(end_lat), cos(start_lat) * sin(end_lat) - sin(start_lat) * cos(end_lat) * cos(end_long - start_long))#
		bearing <- bearing / (pi / 180)#
		bearing <- (bearing + 360) %% 360#
		return(bearing)#
	}#
	# Get theta in radians from great circle distance:#
	GetThetaFromGreatCircleDistance <- function(great_circle_distance, EarthRad = 6367.4447) {#
		# Get theta in radians from great circle distance:#
		great_circle_distance / EarthRad#
	}#
	# Get chord length from theta in radians and radius in km:#
	GetChordLengthFromTheta <- function(theta, EarthRad = 6367.4447) {#
		# Get chord length from theta (in radians):#
		sin(theta / 2) * EarthRad * 2#
	}#
	# Get theta in radians from chord length and radius in km:#
	GetThetaFromChordLength <- function(chord_length, EarthRad = 6367.4447) {#
		# Get theta in radians from chord length and radius in km:#
		asin((chord_length * 0.5) / EarthRad) * 2#
	}#
	# Get great circle distacne from theta in radians and radius in km:#
	GetGreatCircleDistanceFromTheta <- function(theta, EarthRad = 6367.4447) {#
		# Calculate great circle distance from theta in radians:#
		theta * EarthRad#
	}#
	# Get the spherical angle for an equilateral triangle where its sides (as great circle distances) are known:#
	GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength <- function(side_length, EarthRad = 6367.4447) {#
# Check this works for triangles larger than equivalent of 90-degrees of latitude on each side!#
		# Get y (which will be double the opposite for the triangle we are trying to solve):#
		y <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length))#
		# Get z which will be double the hypotenuse for the triangle we are trying to solve):#
		z <- GetChordLengthFromTheta(GetThetaFromGreatCircleDistance(side_length * 2))#
		# Solve the traingle for theta (the spherical angle) and convert to degrees:#
		spherical_angle <- asin((y / 2) / (z / 2)) / (pi / 180) * 2#
		# Return the spherical angle:#
		return(spherical_angle)#
	}
# Establish minimum distance between continent centres (:#
		min_separation <- (1 - squishiness) * radius * 2#
# If squishiness is zero then all continents begin with same centre!!!!!!!#
# Need conditional to reflect this.#
		# Randomly assign starting longitude:#
		first_circle_long <- runif(1, min = -180, max = 180)#
#
		# Randomly assign starting latitude:#
		first_circle_lat <- runif(1, min = -90, max = 90)#
		# Create matrix to store circles:#
		circles <- matrix(c(1, first_circle_long, first_circle_lat), ncol=3, dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
circles
# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))
library(dispeRse)
# Find centre of second continnet by randomly drawing from the circle describing all points within minimum separation of the first continent:#
			second_circle <- EndPoint(slong = first_circle_long, slat = first_circle_lat, bearing = runif(1, min = 0, max = 360), distance = min_separation)#
#
			# Add second continent to circles matrix:#
			circles <- rbind(circles, c(2, second_circle$long, second_circle$lat))
circles
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(first_circle_long, first_circle_lat, second_circle_long, second_circle_lat) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle["long"], third_circle["lat"]))
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(first_circle_long, first_circle_lat, new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle["long"], third_circle["lat"]))
new_continent_2
EndPoint(first_circle_long, first_circle_lat, new_bearing_1, min_separation)
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
new_continent_1
EndPoint
EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)
EndPoint
circles[1, "Longitude"]
sort(circles[1, "Longitude"])
new_continent_1
unlist(new_continent_1)
unlist(new_continent_1, use.names=FALSE)
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1, use.names=FALSE), unlist(new_continent_2, use.names=FALSE))[, c("long", "lat")][sample(c(1, 2), 1), ]
new_continent_2
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")][sample(c(1, 2), 1), ]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 2:£]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 2:3]
circles
rbind(unlist(new_continent_1), unlist(new_continent_2))[, 2:3]
min_separation
circles
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360
new_bearing_1
new_bearing_2
unlist(new_bearing_2)
GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"])
??dimnames
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				dimnames(new_bearing_1) <- dimnames(new_bearing_1) <- NULL
new_bearing_1
new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)
new_continent_1
new_continent_1$long
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")]
rbind(unlist(new_continent_1), unlist(new_continent_2))[, c("long", "lat")
1
rbind(unlist(new_continent_1), unlist(new_continent_2))
?rbind
rbind(unlist(new_continent_1), unlist(new_continent_2), dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
rbind(unlist(new_continent_1), unlist(new_continent_2))
colnames(rbind(unlist(new_continent_1), unlist(new_continent_2)))
rbind(unlist(new_continent_1), unlist(new_continent_2), dimnames=list(c(), c("Circle", "Longitude", "Latitude")))
EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)
EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[, c("long", "lat")]
EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]
EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]
new_continent_1
new_continent_2
rbind(unlist(new_continent_1), unlist(new_continent_2))
rbind(unlist(new_continent_1), unlist(new_continent_2))[sample(c(1, 2), 1), ]
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[sample(c(1, 2), 1), ]
third_circle
rbind(circles, c(3, third_circle))
# Get spherical angle of equilateral (spherical) triangle with sides equal to minimum separation:#
				spherical_angle <- GetSphericalAngleForEquilateralTriangleFromGreatCircleSideLength(min_separation)#
#
				# Get first of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_1 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) - spherical_angle) %% 360#
				# Get second of two possible bearings from centre of first continent to centre of third continent:#
				new_bearing_2 <- (GetBearing(circles[1, "Longitude"], circles[1, "Latitude"], circles[2, "Longitude"], circles[2, "Latitude"]) + spherical_angle) %% 360#
				# Get lat-long coordinates of first possible site of third continent:#
				new_continent_1 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_1, min_separation)[c("long", "lat")]#
				# Get lat-long coordinates of second possible site of third continent:#
				new_continent_2 <- EndPoint(circles[1, "Longitude"], circles[1, "Latitude"], new_bearing_2, min_separation)[c("long", "lat")]#
				# Randomly pick site for third continent:#
				third_circle <- rbind(unlist(new_continent_1), unlist(new_continent_2))[sample(c(1, 2), 1), ]#
				# Add third continent to circles matrix:#
				circles <- rbind(circles, c(3, third_circle))
circles
library(maps)
map()
map()
points(circles[, "Longitude"], circles[, "Latitude"])
points(circles[, "Longitude"], circles[, "Latitude"], pch=19)
points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")
library(maps)#
				map()#
				points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")
library(maps)#
				map()#
				points(circles[, "Longitude"], circles[, "Latitude"], pch=19, col="red")
library(sphereplot)#
#
# Plot spherical grid:#
rgl.sphgrid()
rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=2)
rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=3)
rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", cex=4)
?rgl.sphpoints
?points3d
rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", lwd=4)
rgl.sphgrid()
rgl.sphpoints(circles[, "Longitude"], circles[, "Latitude"], 1, deg=TRUE, col="red", lwd=4)
dist
circles
matrix(c(1,2))
matrix(c(1,2), byrow=TRUE)
matrix(c(1,2), nrow=1, byrow=TRUE)
t(circles)
roxygenise()
library(devtools)
setwd("~/Documents/Publications/in prep/dispeRse")
document()
document()
install_github("laurasoul/dispeRse")#
#
# Load the dispeRse package into R:#
library(dispeRse)
document()
document()
document()
document()
library(Claddis)
library(phytools)
?make.simmap
Michaux1989
rownames(Michaux1989$matrix)
rtree(nrow = rownames(Michaux1989$matrix))
rtree(nrow(Michaux1989$matrix))
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)
tree
plot(tree)
diag(vcv(tree))
max(diag(vcv(tree)))
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
tree$root.time <- max(diag(vcv(tree)))
seq(tree$root.time, 0, length.out=3)
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
tree$root.time <- max(diag(vcv(tree)))#
#
DiscreteCharacterRate(tree, Michaux1989, seq(tree$root.time, 0, length.out=3), alpha=0.01)
set.seed(44)#
#
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
tree$root.time <- max(diag(vcv(tree)))#
#
DiscreteCharacterRate(tree, Michaux1989, seq(tree$root.time, 0, length.out=3), alpha=0.01)
set.seed(17)#
#
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
tree$root.time <- max(diag(vcv(tree)))#
#
DiscreteCharacterRate(tree, Michaux1989, seq(tree$root.time, 0, length.out=3), alpha=0.01)
set.seed(17)#
#
tree <- rtree(nrow(Michaux1989$matrix))#
#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
tree$root.time <- max(diag(vcv(tree)))#
#
DiscreteCharacterRate(tree, Michaux1989, seq(tree$root.time, 0, length.out=3), alpha=0.01)
# Get morphological distances for Michaux (1989) data set:#
distances <- MorphDistMatrix(Michaux1989)
distances
# Get morphological distances for Michaux (1989) data set:#
distances <- MorphDistMatrix(Michaux1989)#
#
# Attempt to trim max.dist.matrix:#
TrimMorphDistMatrix(distances$max.dist.matrix
# Get morphological distances for Michaux (1989) data set:#
distances <- MorphDistMatrix(Michaux1989)#
#
# Attempt to trim max.dist.matrix:#
TrimMorphDistMatrix(distances$max.dist.matrix)
# Set random seed:#
set.seed(17)#
#
# Generate a random tree for the Michaux data set:#
tree <- rtree(nrow(Michaux1989$matrix))#
#
# Update taxon names to match those in the data matrix:#
tree$tip.label <- rownames(Michaux1989$matrix)#
#
# Set root time by making youngest taxon extant:#
tree$root.time <- max(diag(vcv(tree)))#
#
# Get all state changes:#
GetAllStateChanges(Michaux1989, tree, seq(tree$root.time, 0, length.out=3), Nsim=2)
AncStateEstMatrix(Michaux1989, tree)
?utils
?utils
library(devtools)
setwd("~/Documents/Publications/in prep/Claddis/Claddis")
devtools::check()
?utils
devtools::check()
?check
devtools::check()
?devtools
build()
install()
check()
build()
install()
check()
