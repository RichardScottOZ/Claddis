N <- 25#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = rainbow(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
# Made up data for testing:#
  N <- 25#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = rainbow(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  text(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
# Made up data for testing:#
  N <- 25#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = rainbow(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  text(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = rainbow(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  text(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = viridis::magma(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  text(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
DelaunayForVoronoi
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  colnames(DelaunayForVoronoi)
colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)]
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = viridis::magma(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
  text(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]), labels = LETTERS[1:length(sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"]))))])
# Made up data for testing:#
  N <- 100#
  Radius <- runif(n = N, min = 0, max = 2)#
  Angle <- sample(1:360, size = N, replace = TRUE)#
  x <- Radius * cos(Angle * (pi / 180))#
  y <- Radius * sin(Angle * (pi / 180))#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = viridis::magma(length(x))[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))
?magma
viridis_pal(alpha = 1, begin = 0, end = 1, direction = 1, option = "A")
viridis::magma
viridis::magma(begin = min(heat), end = max(heat))
heat <- runif(n = N)
viridis::magma(begin = min(heat), end = max(heat))
viridis::magma(n = N, begin = min(heat), end = max(heat))
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  N <- length(x)#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = , border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  N <- length(x)#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Find points currently outside the plotting circle:#
  #LeftColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  #RightColumnPointsOutsideCircle <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  # LINE MUST CROSS CIRCLE (CANNOT BE INSIDE OR OUTSIDE)#
  CircleLineIntersection <- function(x) {#
    x1 <- x[1]#
    y1 <- x[2]#
    x2 <- x[3]#
    y2 <- x[4]#
    r <- x[5]#
    dx <- x2 - x1#
    dy <- y2 - y1#
    dr <- sqrt((dx ^ 2) + (dy ^ 2))#
    D <- (x1 * y2) - (x2 * y1)#
    delta <- ((r ^ 2) * (dr ^ 2)) - (D ^ 2)#
    if(delta < 0) stop("No intersection between line and circle")#
    if(delta >= 0) {#
      x_plus <- ((D * dy) + (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_plus <- ((-D * dx) + (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      x_minus <- ((D * dy) - (sign(dy) * dx * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      y_minus <- ((-D * dx) - (abs(dy) * sqrt(((r ^ 2) * (dr ^ 2)) - (D ^ 2)))) / (dr ^ 2)#
      if(sign(x1) == 1) x <- x_plus; y <- y_plus#
      if(sign(x1) == -1) x <- x_minus; y <- y_minus#
      return(c(x, y))#
    }#
  }#
  #for(i in LeftColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x1", "y1")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  #for(i in RightColumnPointsOutsideCircle) DelaunayForVoronoi[i, c("x2", "y2")] <- CircleLineIntersection(c(DelaunayForVoronoi[i, "x1"], DelaunayForVoronoi[i, "y1"], DelaunayForVoronoi[i, "x2"], DelaunayForVoronoi[i, "y2"], PlotRadius))#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  N <- length(x)#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labales = 1:N, col = "black", pch = 20, cex = 1)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  #lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")
DelaunayForVoronoi
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "Coordinates"})#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "Coordinates"; return(x)})#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "Coordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:length(x)) {#
    polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
  }#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  #return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #for(i in 1:length(x)) {#
    #polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    #convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    #polygonpoints <- polygonpoints[convexhullpoints, ]#
    #polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
    #}#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  #return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0))#
  #for(i in 1:length(x)) {#
    #polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    #convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    #polygonpoints <- polygonpoints[convexhullpoints, ]#
    #polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
    #}#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  #return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)#
  #for(i in 1:length(x)) {#
    #polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    #convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    #polygonpoints <- polygonpoints[convexhullpoints, ]#
    #polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
    #}#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)#
  #for(i in 1:length(x)) {#
    #polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    #convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    #polygonpoints <- polygonpoints[convexhullpoints, ]#
    #polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
    #}#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
for(i in 1:N) print(i)
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) PolygonsList[[i]][[2]] <- PlotColours[i]; names(PolygonsList[[i]])[2] <- "PlotColour"#
  #return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)
i<-4
PolygonsList[[i]]$PolygonCoordinates[, 1]
PolygonsList[[i]]$PolygonCoordinates[, 2]
plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)
i<-4
polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)
PolygonsList[[i]]$PlotColour
PolygonsList[[i]]
names(PolygonsList[[i]])
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
  PolygonsList[[i]][[2]] <- PlotColours[i]#
  names(PolygonsList[[i]])[2] <- "PlotColour"#
  }
PolygonsList
plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  for(i in 1:N) polygon(x = PolygonsList[[i]]$PolygonCoordinates[, 1], y = PolygonsList[[i]]$PolygonCoordinates[, 2], col = PolygonsList[[i]]$PlotColour, border = 0)
plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  lapply(PolygonsList, funxtion(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))
plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #for(i in 1:length(x)) {#
    #polygonpoints <- rbind(as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind1"] == i, c("x1", "y1")]), as.matrix(DelaunayForVoronoi[DelaunayForVoronoi[, "ind2"] == i, c("x2", "y2")]))#
    #convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    #polygonpoints <- polygonpoints[convexhullpoints, ]#
    #polygon(x = polygonpoints[, 1], y = polygonpoints[, 2], col = PlotColours[i], border = 0)#
    #}#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
DelaunayForVoronoi
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))
DelaunayForVoronoi
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
as.vector(DelaunayForVoronoi[, c("ind1", "ind2")])#
  as.vector(DelaunayForVoronoi[, c("bp1", "bp2")])
vector(DelaunayForVoronoi[, c("ind1", "ind2")])#
  vector(DelaunayForVoronoi[, c("bp1", "bp2")])
c(DelaunayForVoronoi[, c("ind1", "ind2")])#
  c(DelaunayForVoronoi[, c("bp1", "bp2")])
unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]
unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]  unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))])
unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))])
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) print("yep")#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) print(c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x)))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) print(intersect(EdgeIndices, c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))))#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
EdgeIndices
PolygonsList
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) print(DelauneyMatrix[c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x)), ])#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(setdiff(x, c(DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"])))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(c(DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(c(x, DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(c(x, DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(setdiff(x,c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"])))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(setdiff(x, c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"])))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(c(x, c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"])))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    if(sum(EdgeIndices == x) > 0) {#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      ##
      print(setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x))#
    }#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(DelauneyMatrix[AdjacentIndexRows, ])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]
DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]
unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))
unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), "ind1"])#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), "ind2"])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), "ind1"] == AdjacentIndex)#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), "ind2"] == AdjacentIndex)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), "ind1"])#
      print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), "ind2"])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(DelauneyMatrix[AdjacentIndexRows, ])#
      #print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), "ind1"])#
      #print(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), "ind2"])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      #print(DelauneyMatrix[AdjacentIndexRows, ])#
      print(rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")]))#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")]))#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      print(c(x, AdjacentIndex))#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      #print(c(x, AdjacentIndex))#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      print(polygonpoints)#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    print(polygonpoints)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      print(AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      print(AdjacentIndexBlock[which(AdjacentIndexBlock[, 3] == AdjacentIndex), 1:2])#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x1", "y1", "ind1")])#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2")])#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")], DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2")])#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      AdjacentIndexBlock <- rbind(unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")]), unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2")]))#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      Block1 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1")])#
      Block2 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2")])#
      #AdjacentIndexBlock <- rbind(, )#
      print(AdjacentIndex)#
      print(Block1)#
      print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      Block1 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      Block2 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      print(AdjacentIndex)#
      print(Block1)#
      print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(AdjacentIndexRows)#
      # Build adjacent index block:#
      Block1 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      Block2 <- unname(DelauneyMatrix[which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block:#
      Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      print(AdjacentIndex)#
      print(Block1)#
      print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(DelauneyMatrix[AdjacentIndexRows, ])#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), ])#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(rbind(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), , drop = FALSE], DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), , drop = FALSE]))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(rbind(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1"), drop = FALSE], DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2"), drop = FALSE]))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(rbind(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), , drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), , drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(rbind(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), , drop = FALSE], DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), , drop = FALSE]))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE], DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(do.call(rbind, list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(c(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(unlist(c(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(matrix(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), ncol = 3), matrix(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]), ncol = 3)))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      print(AdjacentIndex)#
      print(list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexList <- list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))#
      print(lapply(AdjacentIndexList, ncol))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexList <- list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))#
      print(do.call(rbind, AdjacentIndexList))#
      #print(lapply(AdjacentIndexList, ncol))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexList <- list(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]), unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))#
      print(unlist(AdjacentIndexList))#
      #print(lapply(AdjacentIndexList, ncol))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
matrix(1:4, nrow = 2)
matrix(1:4, nrow = 2, byrow = TRUE)
as.vector(matrix(1:4, nrow = 2, byrow = TRUE))
as.vector(t(matrix(1:4, nrow = 2, byrow = TRUE)))
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexList <- c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE]))))#
      print(AdjacentIndexList)#
      #print(lapply(AdjacentIndexList, ncol))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE)#
      print(AdjacentIndexBlock)#
      #print(lapply(AdjacentIndexList, ncol))#
      # Build adjacent index block:#
      #Block1 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE])#
      #Block2 <- unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, ][AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])#
      #AdjacentIndexBlock <- rbind(, )#
      #print(AdjacentIndex)#
      #print(Block1)#
      #print(Block2)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind"))#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      ##
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
      print(AdjacentIndex)#
      print(AdjacentIndexBlock)#
      # Add additional (adjacent) edge point to polygon points#
      #polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[AdjacentIndexBlock[, 3] == AdjacentIndex, 1:2])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(c(EdgeIndices[EdgeIndices == x], AdjacentIndex))#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(c(EdgeIndices[EdgeIndices == x], AdjacentIndex))#
      print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"])#
      print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])))#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(c(intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))))#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)#
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(c(intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))))#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      print(c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      print(c(CurrentBearing, AdjacentBearing))#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      print(CurrentBearing)#
      print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      #print(CurrentBearing)#
      print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      print(CurrentBearing)#
      #print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      print(c(CurrentBearing, AdjacentBearing))#
      #print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      test <- c(CurrentBearing, AdjacentBearing)#
      print(test)#
      #print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"]))), "bear2"])#
      test <- c(CurrentBearing, AdjacentBearing)#
      print(length(test))#
      #print(AdjacentBearing)#
      #print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(c(, AdjacentIndex))#
      #print(DelauneyMatrix)#
      #DelauneyMatrix[, "x1"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "x2"] == polygonpoints[, 1]#
      #DelauneyMatrix[, "y1"] == polygonpoints[, 2]#
      #DelauneyMatrix[, "y2"] == polygonpoints[, 2]#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      test <- c(CurrentBearing, AdjacentBearing)#
      print(test)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(AdjacentBearing)#
      print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"])#
      # Get bearing of adjacent edge point:#
      #AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(AdjacentBearing)#
      #print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])))#
      # Get bearing of adjacent edge point:#
      #AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(AdjacentBearing)#
      #print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), ])#
      print(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), ])#
      # Get bearing of adjacent edge point:#
      #AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(AdjacentBearing)#
      #print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(AdjacentBearing)#
      print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      #print(AdjacentBearing)#
      print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "bear2"])#
      print(AdjacentBearing)#
      #print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      print(AdjacentBearing)#
      #print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      print(AdjacentBearing)#
      print(CurrentBearing)#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      print(sort(c(AdjacentBearing, CurrentBearing)))#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  for(i in 1:N) {#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  #return(PolygonsList)#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
  #points(x = x, y = y, col = "black", pch = 20, cex = 0.4)#
  text(x = x, y = y, labels = 1:N, col = "black", pch = 20, cex = 1)#
  # Plot outer circle (edge of plot):#
  polygon(x = PlotRadius * cos(seq(from = 0, to = 360, length.out = 361) * (pi / 180)), y = PlotRadius * sin(seq(from = 0, to = 360, length.out = 361) * (pi / 180)))#
  # Plot edge points (as check they are on edge circle):#
  points(x = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "x1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "x2"]), y = c(DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp1"]), "y1"], DelaunayForVoronoi[which(DelaunayForVoronoi[, "bp2"]), "y2"]))#
#
}#
N <- 100#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.1)
(355 - 1) %% 360
(1 - 355) %% 360
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 10000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.25)
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))
EdgeFactor = 1.1
# Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))
for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }
DelaunayForVoronoi[1:10, ]
apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)
which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)
DelaunayForVoronoi[LeftOutsideCirclePoints, ]
LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)
DelaunayForVoronoi[LeftOutsideCirclePoints, ]
NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))
NewX
NewY
LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"]#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }
DelaunayForVoronoi[LeftOutsideCirclePoints, ]
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 10000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.25)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 10000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
N <- 1000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 1000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 5000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::plasma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 5000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 5000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
?rainbow
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  PlotColours <- rainbow(n = N)#
  # Edge points must be placed on circle, any other point outside circle must also be "withdrawn" back to circle edge#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 5000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
heat <- runif(n = N)#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
#' Find ancestor#
#'#
#' Finds last common ancestor (node) of a set of two or more descendant tips.#
#'#
#' Gets data to pot a Voronoi diagram.#
#'#
#' @param descs A vector of mode character representing the tip names for which an ancestor is sought.#
#' @param tree The tree as a phylo object.#
#'#
#' @return \item{anc.node}{The ancestral node number.}#
#'#
#' @author Graeme T. Lloyd \email{graemetlloyd@@gmail.com}#
#'#
#' @keywords ancestor#
#'#
#' @examples#
#'#
#' # Create some example coordinates:#
#' x <- y <- rep(1:10, 10)#
#' y <- sort(y)#
#' x <- x + rnorm(n = 100, mean = 0, sd = 0.1)#
#' y <- y + rnorm(n = 100, mean = 0, sd = 0.1)#
#' ordering <- sample(1:100)#
#' x <- x[ordering]#
#' y <- y[ordering]#
#'#
#' @export Test#
TreespaceTiles <- function(x, y, heat, EdgeFactor = 1.1) {#
  # Check edge factor is a valid value and stop and warn if not:#
  if(EdgeFactor < 1) stop("EdgeFactor must be equal to or greater than 1")#
  # Set total number of values:#
  N <- length(x)#
  # Get Delaunay Triangulation from x and y:#
  DelaunayForVoronoi <- deldir::deldir(x, y)$dirsgs#
  # Add bearings (from origin) to each coordinate as last two columns:#
  DelaunayForVoronoi <- cbind(DelaunayForVoronoi, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y1"]), as.numeric(DelaunayForVoronoi[, "x1"]))) %% 360, ((180 / pi) * atan2(as.numeric(DelaunayForVoronoi[, "y2"]), as.numeric(DelaunayForVoronoi[, "x2"]))) %% 360)#
  # Update column names accordingly:#
  colnames(DelaunayForVoronoi)[(ncol(DelaunayForVoronoi) - 1):ncol(DelaunayForVoronoi)] <- c("Bear1", "Bear2")#
  # Get maximum distance of a sampled point (x_i, y_i) from the origin (0, 0):#
  MaxDistanceFromOrigin <- max(sqrt((x ^ 2) + (y ^ 2)))#
  # Generate plot radius from maximum distance from origin multiplied by some edge factor:#
  PlotRadius <- EdgeFactor * MaxDistanceFromOrigin#
  # Set plot colours using viridis library (probably want to add optiosn for this later):#
  PlotColours <- viridis::magma(n = N, begin = min(heat), end = max(heat))#
  for(i in sort(c(which(DelaunayForVoronoi[, "bp1"]), which(DelaunayForVoronoi[, "bp2"])))) {#
    # Get correct column (first or second):#
    ColumnsToUse <- ifelse(DelaunayForVoronoi[i, "bp1"], "First", "Second")#
    if(ColumnsToUse == "First") Coordinates <- DelaunayForVoronoi[i, c("x1", "y1")]#
    if(ColumnsToUse == "Second") Coordinates <- DelaunayForVoronoi[i, c("x2", "y2")]#
    x1 <- 0#
    y1 <- 0#
    x2 <- Coordinates[1]#
    y2 <- Coordinates[2]#
    Bearing <- (180 / pi) * atan2(as.numeric(y2 - y1), as.numeric(x2 - x1))#
    Bearing <- Bearing %% 360#
    x_new <- PlotRadius * cos(Bearing * (pi / 180))#
    y_new <- PlotRadius * sin(Bearing * (pi / 180))#
    if(ColumnsToUse == "First") DelaunayForVoronoi[i, c("x1", "y1")] <- c(x_new, y_new)#
    if(ColumnsToUse == "Second") DelaunayForVoronoi[i, c("x2", "y2")] <- c(x_new, y_new)#
#
  }#
  LeftOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x1", "y1")] ^ 2, 1, sum)) > PlotRadius)#
  RightOutsideCirclePoints <- which(sqrt(apply(DelaunayForVoronoi[, c("x2", "y2")] ^ 2, 1, sum)) > PlotRadius)#
  if(length(LeftOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[LeftOutsideCirclePoints, "Bear1"] * (pi / 180))#
    DelaunayForVoronoi[LeftOutsideCirclePoints, c("x1", "y1")] <- cbind(NewX, NewY)#
#
  }#
  if(length(RightOutsideCirclePoints) > 0) {#
    NewX <- PlotRadius * cos(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    NewY <- PlotRadius * sin(DelaunayForVoronoi[RightOutsideCirclePoints, "Bear2"] * (pi / 180))#
    DelaunayForVoronoi[RightOutsideCirclePoints, c("x2", "y2")] <- cbind(NewX, NewY)#
  }#
  # Subfunction to get points that describe the convex hull surrounding each datapoint:#
  GetPolygonPoints <- function(x, DelauneyMatrix, EdgeIndices, PlotRadius) {#
    # Get points corresponding to the current index polygon:#
    polygonpoints <- rbind(as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind1"] == x, c("x1", "y1")]), as.matrix(DelauneyMatrix[DelauneyMatrix[, "ind2"] == x, c("x2", "y2")]))#
    # If this is also an edge index (i.e., a polygon that has part of it's edge as the edge of the plot):#
    if(sum(EdgeIndices == x) > 0) {#
      # Set current index (edge point already in sample):#
      CurrentIndex <- x#
#
      # Find the rows of the Delauney matrix that correspond to the current index:#
      IndexRows <- c(which(DelauneyMatrix[, "ind1"] == x), which(DelauneyMatrix[, "ind2"] == x))#
      # Find adjacent index (will decide which additional point needs to be added:#
      AdjacentIndex <- setdiff(c(DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp1"]), "ind1"], DelauneyMatrix[IndexRows, ][which(DelauneyMatrix[IndexRows, "bp2"]), "ind2"]), x)#
      # Find the rows of the Delauney matrix that correspond to the adjacent (edge) index:#
      AdjacentIndexRows <- c(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "ind2"] == AdjacentIndex))#
      # Build adjacent index block (just of rows corresponding to edge values):#
      AdjacentIndexBlock <- matrix(c(as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp1"]), c("x1", "y1", "ind1"), drop = FALSE]))), as.vector(t(unname(DelauneyMatrix[AdjacentIndexRows, ][which(DelauneyMatrix[AdjacentIndexRows, "bp2"]), c("x2", "y2", "ind2"), drop = FALSE])))), ncol = 3, byrow = TRUE, dimnames = list(c(), c("x", "y", "ind")))#
#
      # Add additional (adjacent) edge point to polygon points#
      polygonpoints <- rbind(polygonpoints, AdjacentIndexBlock[which(AdjacentIndexBlock[, "ind"] == AdjacentIndex), c("x", "y")])#
      # Get bearing of current edge point:#
      CurrentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == CurrentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == CurrentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      # Get bearing of adjacent edge point:#
      AdjacentBearing <- c(DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind1"] == AdjacentIndex), which(DelauneyMatrix[, "bp1"])), "Bear1"], DelauneyMatrix[intersect(which(DelauneyMatrix[, "ind2"] == AdjacentIndex), which(DelauneyMatrix[, "bp2"])), "Bear2"])#
      ##
      if((AdjacentBearing - CurrentBearing) %% 360 >= (CurrentBearing - AdjacentBearing) %% 360) {#
        MinBearing <- AdjacentBearing#
        MaxBearing <- CurrentBearing#
      } else {#
        MaxBearing <- AdjacentBearing#
        MinBearing <- CurrentBearing#
      }#
      if(((MaxBearing - MinBearing) %% 360) > 1) {#
      # Get interpolated bearings along edge of plot:#
      InterpolatedBearings <- (ceiling(MinBearing) + c(0:((ifelse(floor(MaxBearing) == 0, 360, floor(MaxBearing)) - ceiling(MinBearing)) %% 360))) %% 360#
      if(length(InterpolatedBearings) > 180) print(InterpolatedBearings)#
      InterpolatedCoordinates <- cbind(PlotRadius * cos(InterpolatedBearings * (pi / 180)), PlotRadius * sin(InterpolatedBearings * (pi / 180)))#
      polygonpoints <- rbind(polygonpoints, InterpolatedCoordinates)#
      }#
    }#
    # Place polygon points in "order", i.e., using a convex hull:#
    convexhullpoints <- chull(x = polygonpoints[, 1], y = polygonpoints[, 2])#
    # Set order of polygon points using convex hull:#
    polygonpoints <- polygonpoints[convexhullpoints, ]#
    # Output polygon points ready for plotting:#
    return(polygonpoints)#
  }#
  # Define deg indices (i.e., indices that share and edge with the edge of the plot):#
  EdgeIndices <- sort(unname(unlist(c(DelaunayForVoronoi[, c("ind1", "ind2")]))[unlist(c(DelaunayForVoronoi[, c("bp1", "bp2")]))]))#
#
  # Build polygon list (of indices, ready for plotting):#
  PolygonsList <- lapply(as.list(1:length(x)), GetPolygonPoints, DelauneyMatrix = DelaunayForVoronoi, EdgeIndices = EdgeIndices, PlotRadius = PlotRadius)#
  # Subset list as coordinates (creates room for adding additional data to each polygon, e.g., heat):#
  PolygonsList <- lapply(PolygonsList, function(x) {x <- list(x); names(x) <- "PolygonCoordinates"; return(x)})#
  # FOr each index:#
  for(i in 1:N) {#
    # Add plot colour to list:#
    PolygonsList[[i]][[2]] <- PlotColours[i]#
    # Add plot colour name to list:#
    names(PolygonsList[[i]])[2] <- "PlotColour"#
  }#
  # Create empty plot:#
  plot(x = x, y = y, type = "n", xlim = c(-PlotRadius, PlotRadius), ylim = c(-PlotRadius, PlotRadius), asp = 1)#
  # Add polygons coloured by heat values:#
  Empty <- lapply(PolygonsList, function(x) polygon(x = x$PolygonCoordinates[, 1], y = x$PolygonCoordinates[, 2], col = x$PlotColour, border = 0))#
#
}#
N <- 5000#
Radius <- runif(n = N, min = 0, max = 2)#
Angle <- sample(1:360, size = N, replace = TRUE)#
x <- Radius * cos(Angle * (pi / 180))#
y <- Radius * sin(Angle * (pi / 180))#
ORDER <- order(x)#
x <- x[ORDER]#
y <- y[ORDER]#
heat <- sort(runif(n = N))#
#
TreespaceTiles(x, y, heat, EdgeFactor = 1.05)
x <- matrix(c("-", "0", "", "+", "1", "", "-", "2", "", "+", "3", "", "-", "4", "", "-", "5", "", "-", "6", "", "-", "7", "", "-", "8", "", "+", "9", "", "-", "10", "-", "11", "-", "12", "-", "13", "-", "14", "", "-", "15", "-", "16", "-", "17", "-", "18", "-", "19", "", "-", "20", "-", "21", "-", "22", "-", "23", "-", "24", "", "-", "25", "-", "26", "-", "27", "-", "28", "+", "29", "", "-", "30", "-", "31", "+", "32", "-", "33", "-", "34", "", "-", "35", "-", "36", "-", "37", "-", "38", "-", "39", "", "-", "40", "-", "41", "-", "42", "-", "43", "+", "44", "", "-", "45", "-", "46", "-", "47", "-", "48", "-", "49", "", "-", "50", "-", "51", "+", "52", "-", "53", "-", "54", "", "-", "55", "-", "56", "+", "57", "-", "58", "-", "59", "", "-", "60", "-", "61", "-", "62", "-", "63", "-", "64", "", "+", "65", "-", "66", "-", "67", "+", "68", "-", "69", "", "+", "70", "+", "71", "-", "72", "+", "73", "-", "74", "", "+", "75", "-", "76", "-", "77", "-", "78", "-", "79", "", "-", "80", "-", "81", "-", "82", "-", "83"
, "-", "84", "", "-", "85", "-", "86", "-", "87", "-", "88", "-", "89", "", "-", "90", "-", "91", "+", "92", "-", "93", "-", "94", "", "-", "95", "-", "96", "-", "97", "-", "98", "-", "99", "", "-", "100", "-", "101", "-", "102", "-", "103", "-", "104", "-", "105", "-", "106", "+", "107", "-", "108", "-", "109", "-", "110", "-", "111", "-", "112", "-", "113", "-", "114", "-", "115", "+", "116", "-", "117", "-", "118", "-", "119", "-", "120", "-", "121", "-", "122", "-", "123", "-", "124", "-", "125", "-", "126", "-", "127", "-", "128", "-", "129", "-", "130", "-", "131", "-", "132", "-", "133", "-", "134", "-", "135", "-", "136", "-", "137", "-", "138", "-", "139", "-", "140", "-", "141", "-", "142", "-", "143", "-", "144", "-", "145", "-", "146", "-", "147", "-", "148", "-", "149", "-", "150", "-", "151", "-", "152", "-", "153", "-", "154", "-", "155", "-", "156", "-", "157", "+", "158", "-", "159", "-", "160", "-", "161", "-", "162", "-", "163", "-", "164", "-", "165", "-", "166", "+", "167", "-", "168",
"-", "169", "-", "170", "-", "171", "-", "172", "-", "173", "-", "174", "+", "175", "-", "176", "-", "177", "-", "178", "-", "179", "-", "180", "-", "181", "+", "182", "-", "183", "-", "184", "-", "185", "-", "186", "-", "187", "-", "188", "-", "189", "-", "190", "-", "191", "-", "192", "-", "193", "+", "194", "-", "195", "-", "196", "-", "197", "+", "198", "-", "199", "-", "200", "-", "201", "-", "202", "-", "203", "-", "204", "+", "205", "-", "206", "-", "207", "-", "208", "-", "209", "-", "210", "-", "211", "+", "212", "+", "213", "-", "214", "+", "215", "-", "216", "-", "217", "+", "218", "-", "219", "-", "220", "-", "221", "-", "222", "-", "223", "-", "224", "-", "225", "-", "226", "-", "227", "+", "228", "-", "229", "-", "230", "-", "231", "+", "232", "+", "233", "-", "234", "-", "235", "-", "236", "-", "237", "-", "238", "-", "239", "-", "240", "-", "241", "-", "242", "-", "243", "-", "244", "-", "245", "-", "246", "-", "247", "-", "248", "-", "249", "-", "250", "-", "251", "-", "252"), ncol = 2, byr
ow = TRUE)[,1]#
paste(which(x == "-"), collapse = " ")#
paste(which(x == "+"), collapse = " ")
paste(c(2,4,20,34,50,51,54,63,72,84,104,106,111,117,127,145,146,158,162,166,174,179,192,193,205,211,217,220,225,237,242,252,291.293,299,302,306,313,318,326,331) + 1, collapse = " ")
paste(setdiff(1:335, (c(2,4,20,34,50,51,54,63,72,84,104,106,111,117,127,145,146,158,162,166,174,179,192,193,205,211,217,220,225,237,242,252,291.293,299,302,306,313,318,326,331) + 1)), collapse = " ")
nchar("11????????????????????????????????????????????????????????????????????????????????????????????1?00001??????0??0111012111??????1100101100000110020?2001010?00201?01111120121?00?0210011100?1?0?100???0?111?00?1100100?11?????????????????????????????1111013101000011111001100111110010?211112??0???1011111?101000??0????????????????????????????????????????????5???????????0?????")
setdiff(1:370, c(8, 13, 19, 23, 40, 57, 69, 92, 102, 108, 117, 121, 134, 144, 147, 149, 150, 157, 167, 170, 171, 177, 205, 207, 222, 227, 242, 251, 254, 277, 294, 299, 336, 342, 349, 353, 370))
paste(setdiff(1:370, c(8, 13, 19, 23, 40, 57, 69, 92, 102, 108, 117, 121, 134, 144, 147, 149, 150, 157, 167, 170, 171, 177, 205, 207, 222, 227, 242, 251, 254, 277, 294, 299, 336, 342, 349, 353, 370)), collapse = " ")
x <- c(40,64.65,68,76,83,109,115,120,153,175,199,216,344)
x<-x+1
x
x <- c(40,64,65,68,76,83,109,115,120,153,175,199,216,344)
x<-x+1
x
paste(x, collapse = " ")
paste(setdiff(1:374, x), collapse = " ")
x <- c("-", "+", "-", "+", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "+", "+", "-", "+", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "-", "-", "-", "-",
"-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "+", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-")
x
x == "-"
which(x == "-")
paste(which(x == "-"), collapse = " ")
paste(which(x == "+"), collapse = " ")
x <- c("-", "+", "-", "+", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "+", "+", "-", "+", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "-", "-", "-", "-",
"-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "+", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-")#
paste(which(x == "-"), collapse = " ")#
paste(which(x == "+"), collapse = " ")
x <- c("-", "+", "-", "+", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "+", "-", "+", "+", "-", "+", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "-", "-", "-", "-",
"-", "-", "+", "-", "-", "-", "-", "-", "-", "+", "+", "-", "+", "-", "-", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "+", "-", "-", "-", "+", "+", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-", "-")#
paste(which(x == "-"), collapse = " ")#
paste(which(x == "+"), collapse = " ")
# Open libraries:#
library(Claddis)#
library(metatree)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp.nex", list.files())]#
#
# Get list of mrp files:#
trees.list <- list.files()[grep("mpts_plus_strict.nex", list.files())]#
#
# Make tree files:#
for(i in 1:length(trees.list)) {#
  # Read in TNT trees and split into mpts and strict consensus:#
  mytrees <- Trees2MPTsAndStrict(trees.list[i])#
  # If the tree limit of 100000 was hit (i.e., not all MPTs are guranteed to have been sampled) or no MRP could be created due to sheer number of trees:#
  if(length(mytrees$mpts) == 100000 || sum(mrp.list == gsub("tntmpts_plus_strict.nex", "mrp.nex", trees.list[i])) == 0) {#
    # Create MRP filename:#
    mrp.filename <- gsub("tntmpts_plus_strict.nex", "mrp.nex", trees.list[i])#
    # If MRP file was generated:#
    if(length(which(mrp.list == mrp.filename)) > 0) {#
      # Remove from MRP list:#
      mrp.list <- mrp.list[-which(mrp.list == mrp.filename)]#
      # Delete raw file as likely too big anyway:#
      file.remove(mrp.filename)#
    }#
    # Create nexus file name:#
    nexus.filename <- gsub("mrp\\.nex", ".nex", mrp.filename)#
    # Read in original matrix:#
    mymatrix <- ReadMorphNexus(paste("~/Documents/Homepage/www.graemetlloyd.com/nexus", "/", nexus.filename, sep = ""))#
    # Write out regular TNT file:#
    WriteMorphTNT(mymatrix, gsub("\\.nex", ".tnt", nexus.filename))#
    # Read in TNT lines:#
    TNT.lines <- readLines(gsub("\\.nex", ".tnt", nexus.filename))#
    # Get TNT data block:#
    tnt.block <- TNT.lines[1:(grep("proc/;", TNT.lines) - 1)]#
    # Create analysis block:#
    anal.block <- paste(c("rseed*;\nhold 999;\nxmult=rss fuse 50 drift 50 ratchet 50;\nmult 50 =tbr drift;\ntsave scratch.tre;\nsave;\ntsave /;", rep("rseed*;\nhold 999;\nxmult=rss fuse 50 drift 50 ratchet 50;\nmult 50 =tbr drift;\ntsave scratch.tre +;\nsave;\ntsave /;", 19), "hold 5000;\nshortread scratch.tre;\nbbreak=tbr;"), collapse = "\n")#
    # Cretae empty vector to store final block:#
    full.block <- vector(mode = "character")#
    # Fill out all blocks for analysis:#
    for(j in 1:20) full.block <- c(full.block, paste(paste(tnt.block, collapse = "\n"), anal.block, "mrp;", paste("export ", gsub("\\.nex", "", nexus.filename), "mrp_", j, ".nex;", sep = ""), sep = "\n"))#
    # Write out TNT file:#
    write(paste(paste(full.block, collapse = "\n"), "\nproc/;\n", sep = ""), gsub("\\.nex", ".tnt", nexus.filename))#
  }#
  # Make file name:#
  file.name <- gsub("tntmpts_plus_strict.nex", "", trees.list[i])#
  # Write out MPTs:#
  write(mytrees$mpts, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mpts", "/", file.name, ".tre", sep = ""))#
  # Write out first MPT:#
  write(mytrees$mpts[1], paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/firstmpt", "/", file.name, ".tre", sep = ""))#
  # Write out strict consensus:#
  write(mytrees$strict, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/sc", "/", file.name, ".tre", sep = ""))#
  # Delete trees file now no longer needed:#
  file.remove(trees.list[i])#
  # Spit out loop position:#
  cat(i, " ")#
}#
#
# Make mrp files:#
for(i in 1:length(mrp.list)) {#
  # Add assumptions block to MRP:#
  x <- paste(c(readLines(mrp.list[i]), "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
  # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
  write(x = x, file = mrp.list[i])#
  # Read in MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Remove root taxon:#
  mymrp$Matrix_1$Matrix <- mymrp$Matrix_1$Matrix[-which(rownames(mymrp$Matrix_1$Matrix) == "ROOT"), ]#
  # Collapse to just unique characters:#
  mymrp <- CompactifyMatrix(mymrp)#
  # Overwrite weights (set all to one):#
  mymrp$Matrix_1$Weights <- rep(1, length(mymrp$Matrix_1$Weights))#
  # Make file name:#
  file.name <- gsub(".nex", "", mrp.list[i])#
  # Isolate MPR taxon names:#
  mrp.names <- rownames(mymrp$Matrix_1$Matrix)#
  # Isolate full names:#
  nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
  # Check to see if MRP names are contracted:#
  if(length(setdiff(mrp.names, nexus.names)) > 0) {#
    # List all contracted names:#
    contracted.names <- setdiff(mrp.names, nexus.names)#
    # For each contracted name:#
    for(j in 1:length(contracted.names)) {#
      # Get matching full name(s):#
      full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
      # Check that there are not multiple matches:#
      if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
      # Overwrite contracted name with full name:#
      rownames(mymrp$Matrix_1$Matrix)[which(rownames(mymrp$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
    }#
  }#
  # Write out MRP in #NEXUS format:#
  WriteMorphNexus(mymrp, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, ".nex", sep = ""))#
  # Delete file once finished:#
  file.remove(mrp.list[i])#
  # Spit out loop position:#
  cat(i, " ")#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}#
#
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}#
#
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/gral/Nesbitt_etal_2017abmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/gral/Nesbitt_etal_2017ab.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]#
#
# For each taxon to be reinserted:#
for(i in TaxaInOrder) {#
    # Print current loop position:#
    cat(paste("Attempting to reinsert taxon ", which(TaxaInOrder == i), " of ", length(TaxaInOrder), "\n", sep = ""))#
    # Check taxon has not already been reinserted:#
    if(sum(rownames(MRP$matrix) == i) == 1) {#
        # Report if found:#
        cat("Taxon already inserted\n")#
    # If not found continue to reinsertion step:#
    } else {#
        # Get senior taxa for current junior:#
        Senior_taxa <- STR$str.list[STR$str.list[, "Junior"] == i, "Senior"]#
        # If there are more than two senior taxa (want to "chunk" the analysis to get around memory issues:#
        if(length(Senior_taxa) > 2) {#
            # Add scores for first senior taxon to MRP matrix as a new row:#
            MRP$matrix <- rbind(MRP$matrix, MRP$matrix[Senior_taxa[1], ])#
            # Give that row the name of the current junior:#
            rownames(MRP$matrix)[nrow(MRP$matrix)] <- i#
            # Now for each subsequent senior taxon:#
            for(j in 2:length(Senior_taxa)) {#
                # Get new MRP row for current junior:#
                NewMRPRow <- c(MRP$matrix[i, ], MRP$matrix[Senior_taxa[j], ])#
#
                # Duplicate matrix:#
                DuplicatedMatrix <- matrix(rep(MRP$matrix, times = 2), nrow = nrow(MRP$matrix), dimnames = list(rownames(MRP$matrix), c()))#
                # Update junior with enw row (includes scorings for jth taxon):#
                DuplicatedMatrix[i, ] <- NewMRPRow#
                # Turn into a proper cladistic matrix:#
                DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
                # Collapse MRP to remove duplicated taxa:#
                DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
                # Overwrite MRP with new matrix:#
                MRP <- DuplicatedMatrix#
            }#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/gral/Nesbitt_etal_2017abmrp.nex")#
        # If there are only one or two senior taxa (no easy way to chunk the task):#
        } else {#
            # Duplicate matrix for every senior taxon:#
            DuplicatedMatrix <- matrix(rep(MRP$matrix, times = length(Senior_taxa)), nrow = nrow(MRP$matrix), dimnames = list(rownames(MRP$matrix), c()))#
            # Get new MRP row for current junior:#
            NewMRPRow <- as.vector(t(MRP$matrix[Senior_taxa, ]))#
            # Add new row to duplicated matrix:#
            DuplicatedMatrix <- rbind(DuplicatedMatrix, NewMRPRow)#
            # Update last row name to current junior:#
            rownames(DuplicatedMatrix)[nrow(DuplicatedMatrix)] <- i#
            # Turn into a proper cladistic matrix:#
            DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
            # Collapse MRP to remove duplicated taxa:#
            DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
            # Overwrite MRP with new matrix:#
            MRP <- DuplicatedMatrix#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/gral/Nesbitt_etal_2017abmrp.nex")#
        }#
    }#
}
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017ab.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]#
#
# For each taxon to be reinserted:#
for(i in TaxaInOrder) {#
    # Print current loop position:#
    cat(paste("Attempting to reinsert taxon ", which(TaxaInOrder == i), " of ", length(TaxaInOrder), "\n", sep = ""))#
    # Check taxon has not already been reinserted:#
    if(sum(rownames(MRP$matrix) == i) == 1) {#
        # Report if found:#
        cat("Taxon already inserted\n")#
    # If not found continue to reinsertion step:#
    } else {#
        # Get senior taxa for current junior:#
        Senior_taxa <- STR$str.list[STR$str.list[, "Junior"] == i, "Senior"]#
        # If there are more than two senior taxa (want to "chunk" the analysis to get around memory issues:#
        if(length(Senior_taxa) > 2) {#
            # Add scores for first senior taxon to MRP matrix as a new row:#
            MRP$matrix <- rbind(MRP$matrix, MRP$matrix[Senior_taxa[1], ])#
            # Give that row the name of the current junior:#
            rownames(MRP$matrix)[nrow(MRP$matrix)] <- i#
            # Now for each subsequent senior taxon:#
            for(j in 2:length(Senior_taxa)) {#
                # Get new MRP row for current junior:#
                NewMRPRow <- c(MRP$matrix[i, ], MRP$matrix[Senior_taxa[j], ])#
#
                # Duplicate matrix:#
                DuplicatedMatrix <- matrix(rep(MRP$matrix, times = 2), nrow = nrow(MRP$matrix), dimnames = list(rownames(MRP$matrix), c()))#
                # Update junior with enw row (includes scorings for jth taxon):#
                DuplicatedMatrix[i, ] <- NewMRPRow#
                # Turn into a proper cladistic matrix:#
                DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
                # Collapse MRP to remove duplicated taxa:#
                DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
                # Overwrite MRP with new matrix:#
                MRP <- DuplicatedMatrix#
            }#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
        # If there are only one or two senior taxa (no easy way to chunk the task):#
        } else {#
            # Duplicate matrix for every senior taxon:#
            DuplicatedMatrix <- matrix(rep(MRP$matrix, times = length(Senior_taxa)), nrow = nrow(MRP$matrix), dimnames = list(rownames(MRP$matrix), c()))#
            # Get new MRP row for current junior:#
            NewMRPRow <- as.vector(t(MRP$matrix[Senior_taxa, ]))#
            # Add new row to duplicated matrix:#
            DuplicatedMatrix <- rbind(DuplicatedMatrix, NewMRPRow)#
            # Update last row name to current junior:#
            rownames(DuplicatedMatrix)[nrow(DuplicatedMatrix)] <- i#
            # Turn into a proper cladistic matrix:#
            DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
            # Collapse MRP to remove duplicated taxa:#
            DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
            # Overwrite MRP with new matrix:#
            MRP <- DuplicatedMatrix#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
        }#
    }#
}
TaxaInOrder
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017ab.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]
TaxaInOrder[1]
i <- TaxaInOrder[1]
sum(rownames(MRP$matrix) == i) == 1
sum(rownames(MRP$Matrix_1$Matrix) == i) == 1
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/eargtl/Nesbitt_etal_2017ab.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]#
#
# For each taxon to be reinserted:#
for(i in TaxaInOrder) {#
    # Print current loop position:#
    cat(paste("Attempting to reinsert taxon ", which(TaxaInOrder == i), " of ", length(TaxaInOrder), "\n", sep = ""))#
    # Check taxon has not already been reinserted:#
    if(sum(rownames(MRP$Matrix_1$Matrix) == i) == 1) {#
        # Report if found:#
        cat("Taxon already inserted\n")#
    # If not found continue to reinsertion step:#
    } else {#
        # Get senior taxa for current junior:#
        Senior_taxa <- STR$str.list[STR$str.list[, "Junior"] == i, "Senior"]#
        # If there are more than two senior taxa (want to "chunk" the analysis to get around memory issues:#
        if(length(Senior_taxa) > 2) {#
            # Add scores for first senior taxon to MRP matrix as a new row:#
            MRP$Matrix_1$Matrix <- rbind(MRP$Matrix_1$Matrix, MRP$Matrix_1$Matrix[Senior_taxa[1], ])#
            # Give that row the name of the current junior:#
            rownames(MRP$Matrix_1$Matrix)[nrow(MRP$Matrix_1$Matrix)] <- i#
            # Now for each subsequent senior taxon:#
            for(j in 2:length(Senior_taxa)) {#
                # Get new MRP row for current junior:#
                NewMRPRow <- c(MRP$Matrix_1$Matrix[i, ], MRP$Matrix_1$Matrix[Senior_taxa[j], ])#
#
                # Duplicate matrix:#
                DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = 2), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
                # Update junior with enw row (includes scorings for jth taxon):#
                DuplicatedMatrix[i, ] <- NewMRPRow#
                # Turn into a proper cladistic matrix:#
                DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
                # Collapse MRP to remove duplicated taxa:#
                DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
                # Overwrite MRP with new matrix:#
                MRP <- DuplicatedMatrix#
            }#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
        # If there are only one or two senior taxa (no easy way to chunk the task):#
        } else {#
            # Duplicate matrix for every senior taxon:#
            DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = length(Senior_taxa)), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
            # Get new MRP row for current junior:#
            NewMRPRow <- as.vector(t(MRP$Matrix_1$Matrix[Senior_taxa, ]))#
            # Add new row to duplicated matrix:#
            DuplicatedMatrix <- rbind(DuplicatedMatrix, NewMRPRow)#
            # Update last row name to current junior:#
            rownames(DuplicatedMatrix)[nrow(DuplicatedMatrix)] <- i#
            # Turn into a proper cladistic matrix:#
            DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
            # Collapse MRP to remove duplicated taxa:#
            DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
            # Overwrite MRP with new matrix:#
            MRP <- DuplicatedMatrix#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Nesbitt_etal_2017abmrp.nex")#
        }#
    }#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}#
#
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/eargtl/Zheng_etal_2018bmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/eargtl/Zheng_etal_2018b.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]#
#
# For each taxon to be reinserted:#
for(i in TaxaInOrder) {#
    # Print current loop position:#
    cat(paste("Attempting to reinsert taxon ", which(TaxaInOrder == i), " of ", length(TaxaInOrder), "\n", sep = ""))#
    # Check taxon has not already been reinserted:#
    if(sum(rownames(MRP$Matrix_1$Matrix) == i) == 1) {#
        # Report if found:#
        cat("Taxon already inserted\n")#
    # If not found continue to reinsertion step:#
    } else {#
        # Get senior taxa for current junior:#
        Senior_taxa <- STR$str.list[STR$str.list[, "Junior"] == i, "Senior"]#
        # If there are more than two senior taxa (want to "chunk" the analysis to get around memory issues:#
        if(length(Senior_taxa) > 2) {#
            # Add scores for first senior taxon to MRP matrix as a new row:#
            MRP$Matrix_1$Matrix <- rbind(MRP$Matrix_1$Matrix, MRP$Matrix_1$Matrix[Senior_taxa[1], ])#
            # Give that row the name of the current junior:#
            rownames(MRP$Matrix_1$Matrix)[nrow(MRP$Matrix_1$Matrix)] <- i#
            # Now for each subsequent senior taxon:#
            for(j in 2:length(Senior_taxa)) {#
                # Get new MRP row for current junior:#
                NewMRPRow <- c(MRP$Matrix_1$Matrix[i, ], MRP$Matrix_1$Matrix[Senior_taxa[j], ])#
#
                # Duplicate matrix:#
                DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = 2), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
                # Update junior with enw row (includes scorings for jth taxon):#
                DuplicatedMatrix[i, ] <- NewMRPRow#
                # Turn into a proper cladistic matrix:#
                DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
                # Collapse MRP to remove duplicated taxa:#
                DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
                # Overwrite MRP with new matrix:#
                MRP <- DuplicatedMatrix#
            }#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Zheng_etal_2018bmrp.nex")#
        # If there are only one or two senior taxa (no easy way to chunk the task):#
        } else {#
            # Duplicate matrix for every senior taxon:#
            DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = length(Senior_taxa)), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
            # Get new MRP row for current junior:#
            NewMRPRow <- as.vector(t(MRP$Matrix_1$Matrix[Senior_taxa, ]))#
            # Add new row to duplicated matrix:#
            DuplicatedMatrix <- rbind(DuplicatedMatrix, NewMRPRow)#
            # Update last row name to current junior:#
            rownames(DuplicatedMatrix)[nrow(DuplicatedMatrix)] <- i#
            # Turn into a proper cladistic matrix:#
            DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
            # Collapse MRP to remove duplicated taxa:#
            DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
            # Overwrite MRP with new matrix:#
            MRP <- DuplicatedMatrix#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Zheng_etal_2018bmrp.nex")#
        }#
    }#
}
# Get functions in:#
library(Claddis)#
library(ade4)#
library(foreach)#
library(doParallel)#
#
# Register parallel back end as number of cores available:#
registerDoParallel(cores = 4)#
#
# Set working directory:#
setwd("/Users/eargtl")#
#
# Get list of mrp files:#
mrp.list <- list.files()[grep("mrp_", list.files())]#
#
# For each MRP file:#
for(i in 1:length(mrp.list)) {#
  # Read in raw MRP file:#
  x <- readLines(mrp.list[i])#
  # If there is no assumptions block:#
  if(length(grep("begin assumptions", x, ignore.case = TRUE)) == 0) {#
    # Add assumptions block to MRP:#
    x <- paste(c(x, "BEGIN ASSUMPTIONS;", "OPTIONS  DEFTYPE=unord PolyTcount=MINSTEPS ;", "END;"), collapse = "\n")#
    # Write out MRP file with assumptions added (can then be read in with ReadMorphNexus):#
    write(x = x, file = mrp.list[i])#
  }#
}#
#
# Make mrp files:#
x <- foreach(i = 1:length(mrp.list), .combine = "rbind") %dopar% {#
#
  # Read in ith MRP file:#
  mymrp <- ReadMorphNexus(mrp.list[i])#
  # Compactify the matrix:#
  mymrp <- CompactifyMatrix(mymrp)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(mymrp$Matrix_1$Weights > 10)) mymrp$Matrix_1$Weights[which(mymrp$Matrix_1$Weights > 10)] <- 10#
  # If any rogue NAs are found prune these from the data:#
  if(length(unique(as.vector(mymrp$Matrix_1$Matrix))) > 2) mymrp <- MatrixPruner(mymrp, characters2prune = which((apply(apply(mymrp$Matrix_1$Matrix, 2, '==', "0") + apply(mymrp$Matrix_1$Matrix, 2, '==', "1"), 2, sum)) < nrow(mymrp$Matrix_1$Matrix)))#
#
  # Overwrite original data with compactified version:#
  WriteMorphNexus(mymrp, mrp.list[i])#
}#
#
# Get unique data set names:#
data.sets <- unique(matrix(unlist(strsplit(mrp.list, "mrp_")), ncol = 2, byrow = TRUE)[, 1])#
#
# For each data set:#
for(i in 1:length(data.sets)) {#
  # Get numbers for files to read in:#
  files.to.load <- grep(data.sets[i], mrp.list)#
  # For each file in data set:#
  for(j in files.to.load) {#
    # Read in current matrix:#
    current.matrix <- ReadMorphNexus(mrp.list[j])#
    # Sort by row name to ensure taxa line up later:#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[sort(rownames(current.matrix$Matrix_1$Matrix)), ]#
    # If first file of data set:#
    if(files.to.load[1] == j) {#
      # Set matrix using current matrix:#
      MATRIX <- current.matrix$Matrix_1$Matrix#
      # Set weights using current matrix:#
      WEIGHTS <- current.matrix$Matrix_1$Weights#
    # If not first file of data set:#
    } else {#
      # Add current matrix to data set:#
      MATRIX <- cbind(MATRIX, current.matrix$Matrix_1$Matrix)#
      # Add current weights to data set:#
      WEIGHTS <- c(WEIGHTS, current.matrix$Matrix_1$Weights)#
    }#
  }#
  # Overwrite current matrix with full data set:#
  current.matrix$Matrix_1$Matrix <- MATRIX#
  # Overwrite current matrix weights with full data set:#
  current.matrix$Matrix_1$Weights <- WEIGHTS#
  # Set ordering for full data set:#
  current.matrix$Matrix_1$Ordering <- rep("unord", ncol(current.matrix$Matrix_1$Matrix))#
  # Set maximum values for full data set:#
  current.matrix$Matrix_1$MinVals <- rep(1, ncol(current.matrix$Matrix_1$Matrix))#
  # Set minimum values for full data set:#
  current.matrix$Matrix_1$MaxVals <- rep(0, ncol(current.matrix$Matrix_1$Matrix))#
  # Collapse data set:#
  current.matrix <- CompactifyMatrix(current.matrix)#
  # To avoid non-numeric weight (e.g., 1+e05) set all weights above ten to ten:#
  if(sum(current.matrix$Matrix_1$Weights > 10)) current.matrix$Matrix_1$Weights[which(current.matrix$Matrix_1$Weights > 10)] <- 10#
  # Make file name:#
  file.name <- data.sets[i]#
  # Case if MRP is done (minimum weight is greater than 1):#
  if(min(current.matrix$Matrix_1$Weights) > 1) {#
    # Remove "ROOT" taxon if present:#
    if(sum(rownames(current.matrix$Matrix_1$Matrix) == "ROOT") > 0) current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[-which(rownames(current.matrix$Matrix_1$Matrix) == "ROOT"), ]#
    # Collapse matrix again:#
    current.matrix <- CompactifyMatrix(current.matrix)#
    # Overwrite all weights with 1:#
    current.matrix$Matrix_1$Weights <- rep(1, length(current.matrix$Matrix_1$Weights))#
    # Update matrix in nesting order (outgroup first):#
    current.matrix$Matrix_1$Matrix <- current.matrix$Matrix_1$Matrix[names(sort(apply(apply(current.matrix$Matrix_1$Matrix, 1, as.numeric), 2, sum))), ]#
    # Isolate MRP taxon names:#
    mrp.names <- rownames(current.matrix$Matrix_1$Matrix)#
    # Isolate full names:#
    nexus.names <- rownames(ReadMorphNexus(paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/nexus/", gsub("mrp", "", file.name), ".nex", sep = ""))$Matrix_1$Matrix)#
    # Check to see if MRP names are contracted:#
    if(length(setdiff(mrp.names, nexus.names)) > 0) {#
      # List all contracted names:#
      contracted.names <- setdiff(mrp.names, nexus.names)#
      # For each contracted name:#
      for(j in 1:length(contracted.names)) {#
        # Get matching full name(s):#
        full.name <- nexus.names[grep(contracted.names[j], nexus.names)]#
        # Check that there are not multiple matches:#
        if(length(full.name) > 1) stop("Multiple names match contracted form. Check manually.")#
        # Overwrite contracted name with full name:#
        rownames(current.matrix$Matrix_1$Matrix)[which(rownames(current.matrix$Matrix_1$Matrix) == contracted.names[j])] <- full.name#
      }#
    }#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/Documents/Homepage/www.graemetlloyd.com/mrp", "/", file.name, "mrp.nex", sep = ""))#
    # Remove dead files:#
    file.remove(c(mrp.list[files.to.load], paste(file.name, ".tnt", sep = "")))#
  # Case if MRP needs to continue (minimum weight is 1):#
  } else {#
    # Remove dead files:#
    file.remove(mrp.list[files.to.load])#
    # Write out MRP in #NEXUS format:#
    WriteMorphNexus(current.matrix, paste("/Users/eargtl/", file.name, "mrp_0.nex", sep = ""))#
  }#
  # Output loop position:#
  cat(i, " ")#
}
Arcila_etal_2015ab
# NB: Assumes you have already sent an STR version of the data set through the full protocol to completion (min weight greater than zero)#
#
# Load libraries:#
library(Claddis)#
library(metatree)#
#
# Read in target MRP:#
MRP <- ReadMorphNexus("/Users/eargtl/Arcila_etal_2015abmrp.nex")#
#
# Read in source NEXUS:#
NEXUS <- ReadMorphNexus("/Users/eargtl/Arcila_etal_2015ab.nex")#
#
# Perform STR on NEXUS toget reinsertion list:#
STR <- SafeTaxonomicReduction(NEXUS)#
#
# Order taxa so can reinsert in order of fewest to most senior taxa:#
TaxaInOrder <- rle(sort(STR$str.list[, 1]))$values[order(rle(sort(STR$str.list[, 1]))$lengths)]#
#
# For each taxon to be reinserted:#
for(i in TaxaInOrder) {#
    # Print current loop position:#
    cat(paste("Attempting to reinsert taxon ", which(TaxaInOrder == i), " of ", length(TaxaInOrder), "\n", sep = ""))#
    # Check taxon has not already been reinserted:#
    if(sum(rownames(MRP$Matrix_1$Matrix) == i) == 1) {#
        # Report if found:#
        cat("Taxon already inserted\n")#
    # If not found continue to reinsertion step:#
    } else {#
        # Get senior taxa for current junior:#
        Senior_taxa <- STR$str.list[STR$str.list[, "Junior"] == i, "Senior"]#
        # If there are more than two senior taxa (want to "chunk" the analysis to get around memory issues:#
        if(length(Senior_taxa) > 2) {#
            # Add scores for first senior taxon to MRP matrix as a new row:#
            MRP$Matrix_1$Matrix <- rbind(MRP$Matrix_1$Matrix, MRP$Matrix_1$Matrix[Senior_taxa[1], ])#
            # Give that row the name of the current junior:#
            rownames(MRP$Matrix_1$Matrix)[nrow(MRP$Matrix_1$Matrix)] <- i#
            # Now for each subsequent senior taxon:#
            for(j in 2:length(Senior_taxa)) {#
                # Get new MRP row for current junior:#
                NewMRPRow <- c(MRP$Matrix_1$Matrix[i, ], MRP$Matrix_1$Matrix[Senior_taxa[j], ])#
#
                # Duplicate matrix:#
                DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = 2), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
                # Update junior with enw row (includes scorings for jth taxon):#
                DuplicatedMatrix[i, ] <- NewMRPRow#
                # Turn into a proper cladistic matrix:#
                DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
                # Collapse MRP to remove duplicated taxa:#
                DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
                # Overwrite MRP with new matrix:#
                MRP <- DuplicatedMatrix#
            }#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Arcila_etal_2015abmrp.nex")#
        # If there are only one or two senior taxa (no easy way to chunk the task):#
        } else {#
            # Duplicate matrix for every senior taxon:#
            DuplicatedMatrix <- matrix(rep(MRP$Matrix_1$Matrix, times = length(Senior_taxa)), nrow = nrow(MRP$Matrix_1$Matrix), dimnames = list(rownames(MRP$Matrix_1$Matrix), c()))#
            # Get new MRP row for current junior:#
            NewMRPRow <- as.vector(t(MRP$Matrix_1$Matrix[Senior_taxa, ]))#
            # Add new row to duplicated matrix:#
            DuplicatedMatrix <- rbind(DuplicatedMatrix, NewMRPRow)#
            # Update last row name to current junior:#
            rownames(DuplicatedMatrix)[nrow(DuplicatedMatrix)] <- i#
            # Turn into a proper cladistic matrix:#
            DuplicatedMatrix <- MakeMorphMatrix(CTmatrix = DuplicatedMatrix)#
            # Collapse MRP to remove duplicated taxa:#
            DuplicatedMatrix <- MRPCollapse(DuplicatedMatrix)#
            # Overwrite MRP with new matrix:#
            MRP <- DuplicatedMatrix#
            # Write out new MRP:#
            WriteMorphNexus(MRP, "/Users/eargtl/Arcila_etal_2015abmrp.nex")#
        }#
    }#
}
library(Claddis)
?MorphDistMatrix
setwd("~/Documents/Packages/Claddis/Claddis")
library(devtools)
check()
install()
library(Claddis)
?MorphDistMatrix
